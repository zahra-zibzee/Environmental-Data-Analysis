
```{python}
import json
import pandas as pd
```

```{python}

def read_geojason(file_path: str | os.PathLike, plot_num: int) -> pd.DataFrame:
    with open(file_path) as f:
        data = json.load(f)
    data = pd.DataFrame([i["properties"] | i['geometry'] for i in data["features"]])
    data['x'] = data['coordinates'].apply(lambda x: x[0])
    data['y'] = data['coordinates'].apply(lambda x: x[1])
    data = data.drop(columns=['coordinates'])

    # filter data by plot number
    data = data[data["plot"] == plot_num]
    return data
```

```{python}
import scipy.spatial

def local_maxima_filter(cloud: np.ndarray, window_size: float) -> np.ndarray:
    """Detect local maxima in the point cloud with a fixed window size."""
    
    assert isinstance(cloud, np.ndarray), f"Cloud needs to be a numpy array, not {type(cloud)}"
    
    # cloud = cloud[cloud[:, 2] > height_threshold]
    tree = scipy.spatial.KDTree(data=cloud)
    seen_mask = np.zeros(cloud.shape[0], dtype=bool)
    local_maxima = []

    for i, point in enumerate(cloud):
        if seen_mask[i]:
            continue
        neighbor_indices = tree.query_ball_point(point, window_size)
        highest_neighbor = neighbor_indices[cloud[neighbor_indices, 2].argmax()]
        seen_mask[neighbor_indices] = True
        seen_mask[highest_neighbor] = False 
        # This may lead to not every point being marked as seed in the end, but it does not matter,
        # because by the time the seen value is overwritten the point is already processed
        if i == highest_neighbor:
            local_maxima.append(i)

    return cloud[local_maxima]

```

```{python}

def test_local_maxima(window_sizes: list):
    for plot_num in range(1, 11):
        print(f"Plot {plot_num}")
        gt_data = read_geojason("data/field_survey.geojson", plot_num)
        points = laspy.read(f"data/als/plot_{plot_num:02d}.las")
        for window_size in window_sizes:
            lm_points = local_maxima_filter(points.xyz, window_size)
            point_distances = []
            for lm_point in lm_points:
                min_distance = np.inf
                for gt_point in gt_data[['x', 'y']].values:
                    distance = np.linalg.norm(lm_point[:2] - gt_point)
                    if distance < min_distance:
                        min_distance = distance
                point_distances.append(min_distance)
            point_distances = [float(distance) for distance in point_distances]
            print(f"Window size: {window_size}")
            # print("Sum distance:", np.sum(point_distances))
            # print("Median distance:", np.median(point_distances))
            print("local maxima filter (number of trees):", lm_points.shape[0])
            print("ground truth (number of trees):", gt_data.shape[0])
        # plt.figure(figsize=(10, 5))
        # plt.hist(point_distances, bins=20, color='skyblue', edgecolor='black')
        # plt.xlabel('Distance to nearest ground truth point')
        # plt.ylabel('Frequency')
        # plt.show()

test_local_maxima([2, 2.5, 3, 3.5, 4])
        
